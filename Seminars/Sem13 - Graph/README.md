
## Задача 1 
Имплеметирайте Дийкстра без и с приоритетна опашка.

## Задача 2  (Контролно 2019/20)
** Нека имаме ориентиран граф от символи **g** и двоично дърво от символи **t**.  
Множеството от елементите на двете структури е едно и също, като в рамките на всяка една от структурите символите са уникални.  
Напишете функция, която *проверява дали съществува път от корена на дървото до листо, който да отговаря на път в графа*, и ако има такъв, го извежда.  
(*Заб.:* достатъчно е да изведете само един път, който отговаря на условието).  

***Пример:*** Пътят a - f - c - h отговаря на условието.  

![alt_text](https://i.ibb.co/HFJTk8d/Graph-Tree.png)

```c++
template <typename T>
struct Node
{
    T data;
    Node* left;
    Node* right;

    Node(const T& data, Node* left = nullptr, Node* right = nullptr) : data(data), left(left), right(right) {};
};

	Node<char>* root = new Node<char>('a');
	Node<char>* n1 = new Node<char>('e');
	Node<char>* n2 = new Node<char>('f');
	Node<char>* n3 = new Node<char>('d');
	Node<char>* n4 = new Node<char>('g');
	Node<char>* n5 = new Node<char>('c');
	Node<char>* n6 = new Node<char>('b');
	Node<char>* n7 = new Node<char>('h');
	root->left = n1;
	root->right = n2;
	n1->left = n3;
	n1->right = n4;
	n2->right = n5;
	n3->left = n6;
	n5->left = n7;

	Graph g;
	g.addEdge('a', 'f');
	g.addEdge('a', 'd');
	g.addEdge('b', 'h');
	g.addEdge('c', 'h');
	g.addEdge('d', 'e');
	g.addEdge('e', 'h');
	g.addEdge('f', 'h');
	g.addEdge('f', 'c');
	g.addEdge('g', 'b');
	g.addEdge('g', 'e');

	findPath(g, root);
```


## Задача 3
 От стандартния вход постъпват две естествени числа N ≤ 50 и K ≤ 2500, последвани от K на брой двойки от естествени числа (vi, ui), i = 0,...,K-1. Въведените стойности дефинират **неориентиран**  граф граф G: <V={0,...,N-1}, E={(vi, ui) | i = 0,...,K-1} U {(ui, vi) | i = 0,...,K-1}}. Да се реализира подходящо представяне на графа и за така въведения граф да се намери и изведе на стандартния изход:

1.  Броя на различните му свързани компоненти.
2.  За всяка свързана компонента да се изведе списък с върховете, които принадлежат към нея.
3.  Информацията за свързаните компоненти да се изведе подредена относно броя на елементите им.

## Задача 4
Даден е ориентиран граф от уникални символи g. Да се напише функция, която приема графа и дума с произволна дължина и проверява дали думата може да се получи чрез конкатенирането на последователни различни върхове в графа.

## Задача 5
Да се напише функция, която намира сумата на най - големите елементи на отделните свързани компоненти в (неориентиран) граф.